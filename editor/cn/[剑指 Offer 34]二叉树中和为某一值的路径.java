/**
<p>ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ <code>root</code> å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ <code>targetSum</code> ï¼Œæ‰¾å‡ºæ‰€æœ‰ <strong>ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹</strong> è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚</p>

<p><strong>å¶å­èŠ‚ç‚¹</strong> æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" /></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
<strong>è¾“å‡ºï¼š</strong>[[5,4,11,2],[5,8,4,5]]
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" /></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root = [1,2,3], targetSum = 5
<strong>è¾“å‡ºï¼š</strong>[]
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root = [1,2], targetSum = 0
<strong>è¾“å‡ºï¼š</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul> 
 <li>æ ‘ä¸­èŠ‚ç‚¹æ€»æ•°åœ¨èŒƒå›´ <code>[0, 5000]</code> å†…</li> 
 <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> 
 <li><code>-1000 &lt;= targetSum &lt;= 1000</code></li> 
</ul>

<p>æ³¨æ„ï¼šæœ¬é¢˜ä¸ä¸»ç«™ 113&nbsp;é¢˜ç›¸åŒï¼š<a href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a></p>

<div><div>Related Topics</div><div><li>æ ‘</li><li>æ·±åº¦ä¼˜å…ˆæœç´¢</li><li>å›æº¯</li><li>äºŒå‰æ ‘</li></div></div><br><div><li>ğŸ‘ 403</li><li>ğŸ‘ 0</li></div>
*/

//leetcode submit region begin(Prohibit modification and deletion)

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    List<List<Integer>> ret = new LinkedList<List<Integer>>();
//    Deque<Integer> path = new LinkedList<Integer>();
    Map<TreeNode, TreeNode> map = new HashMap<TreeNode, TreeNode>();


    public List<List<Integer>> pathSum(TreeNode root, int target) {
//        dfs(root, target);
//        return ret;
        if(root == null) {
            return ret;
        }

        Queue<TreeNode> queueNode = new LinkedList<TreeNode>();
        Queue<Integer> queueSum = new LinkedList<Integer>();
        queueNode.offer(root);
        queueSum.offer(0);

        while(!queueNode.isEmpty()) {
            TreeNode node = queueNode.poll();
            int rec = queueSum.poll() + node.val;

            if (node.left == null && node.right == null) {
                if (rec == target) {
                    getPath(node);
                }
            } else {
                if (node.left != null) {
                    map.put(node.left, node);
                    queueNode.offer(node.left);
                    queueSum.offer(rec);

                }
                if (node.right!=null) {
                    map.put(node.right, node);
                    queueNode.offer(node.right);
                    queueSum.offer(rec);

                }
            }
        }

        return ret;
    }

    public void getPath(TreeNode node) {
        List<Integer> temp = new LinkedList<Integer>();

        while (node != null) {
            temp.add(node.val);
            node = map.get(node);
        }
        Collections.reverse(temp);
        ret.add(new LinkedList<Integer>(temp));
    }

//    public void dfs(TreeNode root, int target) {
//        if (root == null) {
//            return;
//        }
//        path.offerLast(root.val);
//        target -= root.val;
//        if (root.left == null && root.right == null && target == 0) {
//            ret.add(new LinkedList<Integer>(path));
//        }
//        dfs(root.left, target);
//        dfs(root.right, target);
//        path.pollLast();
//
//    }
}
//leetcode submit region end(Prohibit modification and deletion)
